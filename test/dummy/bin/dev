#!/usr/bin/env ruby
# frozen_string_literal: true

require "English"

ENGINE_ROOT = File.expand_path("../../..", __dir__)
DUMMY_ROOT  = File.expand_path("..", __dir__)

def ensure_asset_build!(root)
  css_path = File.join(root, "app/assets/builds/source_monitor/application.css")
  js_path  = File.join(root, "app/assets/builds/source_monitor/application.js")
  return if File.exist?(css_path) && File.exist?(js_path)

  env = { "BUNDLE_GEMFILE" => File.join(root, "Gemfile") }
  command = [ "bundle", "exec", "rake", "app:source_monitor:assets:build" ]

  puts "Prebuilding SourceMonitor asset bundles..."
  system(env, *command, chdir: root, exception: true)
end

ensure_asset_build!(ENGINE_ROOT)

css_watch_command = [ "npm", "run", "build:css:watch" ]
js_watch_command  = [ "npm", "run", "build:js:watch" ]

server_command = [
  "bundle", "exec", "rails", "server", *ARGV
]

commands = [
  { name: "css", dir: ENGINE_ROOT, env: {}, command: css_watch_command },
  { name: "js", dir: ENGINE_ROOT, env: {}, command: js_watch_command },
  {
    name: "web",
    dir: DUMMY_ROOT,
    env: { "BUNDLE_GEMFILE" => File.join(DUMMY_ROOT, "Gemfile") },
    command: server_command
  },
  {
    name: "jobs",
    dir: DUMMY_ROOT,
    env: { "BUNDLE_GEMFILE" => File.join(DUMMY_ROOT, "Gemfile") },
    command: [ "bin/jobs", "start" ]
  }
]

pids = {}

commands.each do |entry|
  env      = { "BUNDLE_GEMFILE" => File.join(ENGINE_ROOT, "Gemfile") }.merge(entry[:env])
  cmd      = entry[:command]
  dir      = entry[:dir]
  label    = entry[:name]

  $stdout.puts "Starting #{label}: #{cmd.join(' ')} (chdir=#{dir})"
  pid = Process.spawn(env, *cmd, chdir: dir, out: $stdout, err: $stderr)
  pids[label] = pid
end

stop = lambda do
  pids.each_value do |pid|
    begin
      Process.kill("INT", pid)
    rescue Errno::ESRCH
      next
    end
  end
end

trap("INT") { stop.call }
trap("TERM") { stop.call }

begin
  Process.waitall
rescue Interrupt
  stop.call
  Process.waitall rescue nil
ensure
  pids.each_value do |pid|
    begin
      Process.kill("TERM", pid)
    rescue Errno::ESRCH
      next
    end
  end
end
